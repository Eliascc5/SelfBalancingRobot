
enum movimientos{avanzar,retroceder,girar,bloquearse}mov;
enum testado{adelante, atras, quieto}estado;

uint8_t indcom; // índice para llenar el buffer de recepción
char comando[30]; // buffer de recepción

void InterpretaComando(void){
int aux;
switch(comando[0]){

/****************************************************
en este primer parte se podria plantear consulta de estado. SI esta avanzando retorcediendo ,girando ,etc
*****************************************************/
// case 'C': //Consulta
// switch(comando[1]){
// case 'E': //Estado
// switch(comando[2]){
// case '2':
// estado=adelante;
// printf("Estado:%x\r\n",estado);
// break;
// case '1':
// estado=atras;
// printf("Estado:%x\r\n",estado);
// break;
// case '0':
// estado=quieto;
// printf("Estado:%x\r\n",estado);
// break;
// default:
// printf("Estado:%x\r\n",estado);
// break;
// }
// }


case 'S': //SETPOINT
switch(comando[1]){
case 'T':
if(comando[2]){ // si es distinto de 0
aux = atoi(&comando[2]);

if (aux<=SETPOINT && aux>=SETPOINT_MARGEN){
//AVANZAR O RETROCERDER

}else if (aux>=SETPOINT && aux<=SETPOINT_MARGEN){
//avanzar o rectroceder
}
}else{
//BLOQEUARSE E IMPRIMIR SET POINT
printf("ST:%d\r\n",SETPOINT);
}
break;
}
}
}




ISR(USART_RX_vect){
char dato;
dato=getc();
switch(dato){
case ':': // Delimitador de inicio
indcom=0; // Inicializa índice de buffer de recepción
break;
case '/': // Delimitador de inicio
indcom=0; // Inicializa índice de buffer de recepción
break;
case '\r': // Delimitador de final
comando[indcom]=0; // coloca \0 luego del último caracter recibido antes de \r
InterpretaComando();// Llama a función intérprete de comandos
break;
case ';': // Delimitador de final
comando[indcom]=0; // coloca \0 luego del último caracter recibido antes de ;
InterpretaComando();// Llama a función intérprete de comandos
break;
default: // Todo lo que está entre delimitadores,
comando[indcom++]=dato; // Guarda en elemento del buffer e incrementa indcom para apuntar a siguiente
break;
}
}




int main(){



indcom=0;
UCSR0B|= (1<<RXCIE0); // Interrupcion Rx UART0
sei(); // Interrupcion global



return 0 ;
}
